day03 이어서

# 네트워크 연결 구성하기

## ip

아래 명령어들은 쓰지 않는 것을 권고하지만, 아직 많이 쓰임
Docker에서도 최소 설치 시 제외됨(`net-tools` 설치 필요)
- ifconfig
- route

`ip`로 가능
```bash
$ ip addr
$ ip route
$ ip neigh
```
- 하지만, 실제로 `ip` 명령어 보단 전통적인 명령어를 주로 사용한다.

## DNS Client
FQDN: `호스트` + `도메인명`

## NetwokManager
CentOS5 버전부터 존재
7버전에서 개선

### nmcli
- `nmtui`: gui 기반
- `nmcli`: 명령어 기반

#### nmcli로 네트워크 추가/수정 하기
```bash
# VM
$ nmcli dev # 인식된 네트워크 디바이스 확인
DEVICE      TYPE      STATE      CONNECTION 
virbr0      bridge    connected  virbr0     
enp2s0      ethernet  connected  enp2s0     
vnet0       tun       connected  vnet0      
lo          loopback  unmanaged  --         
virbr0-nic  tun       unmanaged  --  

$ nmcli connection 
NAME    UUID                                  TYPE            DEVICE 
eth0    72df41d4-f64a-47cd-8e08-0913b0e575f0  eth0   
virbr0  b0f9fc63-ce98-4c74-b36b-2886b9c61bea  bridge          virbr0 

$ ls /etc/sysconfig/network-scripts/ # 조회된 리스트들이 현재 설정된 네트워크들
... ifcfg-enp2s0 ifcfg-eth0 ...
$ nmcli con delete eth0 # 설정 파일 제거
Connection 'eth0' (72df41d4-f64a-47cd-8e08-0913b0e575f0) successfully deleted.
$ nmcli con delete 'Wired connection 1' # network-scripts 에서 아직 조회되기 때문에 삭제, eth0은 설정 파일만 지운 것이고 이 명령어도 추가하여 완전히 제거
Connection 'Wired connection 1' (241d59dd-6cb8-3957-ad76-979b67348c55) successfully deleted.

$ nmcli con add type ethernet con-name eth0 ifname eth0
Connection 'eth0' (fe91efcb-a949-4ae4-aac9-cbd0e1f9deec) successfully added.

## 설정 파일 만들기
$ nmcli con modify eth0 ipv4.addresses 192.168.122.149/24 ipv4.gateway 192.168.122.1 ipv4.dns 192.168.122.1 ipv4.method manual ipv4.method manual autoconnect yes

$ nmcli con show eth0 | grep ipv4

$ systemctl restart network # 수정 적용

$ ifconfig eth0 # 확인
```
- `nmlci con modify`
	- DHCP로 자동으로 받아오려는 경우  address, gateway, dns 모두 필요 없고 method을 `auto`로 해주면 된다.
	- method: `manual|auto` DHCP
	- autoconnect: 자동으로 설정 적용할 지 

#### nmtui로 추가한 네트워크 설정 확인하기

ping 확인
1. 자기 자신
2. 게이트웨이
3. 외부 네트워크(kornet)
4. DNS
```bash
# VM
$ ping -c 3 localhost # 자기 자신
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.031 ms
64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.054 ms
64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.054 ms

--- localhost ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 0.031/0.046/0.054/0.012 ms

$ ping -c 3 192.168.122.1 # 게이트웨이
... 생략

$ ping -c 3 168.126.63.1 # 외부 네트워크
... 생략

$ ping -c 3 www.google.co.kr # DNS
... 생략

```

##### nslookup
```bash
$ nslookup www.daum.net # non-interactive, 결과가 나오고 프롬프트 끝
Server:		192.168.122.1
Address:	192.168.122.1#53

Non-authoritative answer:
www.daum.net	canonical name = www.g.daum.net.
Name:	www.g.daum.net
Address: 203.133.167.16
Name:	www.g.daum.net
Address: 203.133.167.81

$ nslookp # interactive, 대화형 (결과는 길기 때문에 생략, 직접 써보길)
> www.naver.com
> set type=mx
> naver.com
> set type=ns
> naver.com
> set type=a
> www.naver.com
```
- set
	- mx: 메일 서버 확인
	- ns: 네임 서버 확인

##### dig
```bash
$ dig www.naver.com

; <<>> DiG 9.9.4-RedHat-9.9.4-38.el7_3.3 <<>> www.naver.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 8264
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 3, ADDITIONAL: 4

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.naver.com.			IN	A

;; ANSWER SECTION:
www.naver.com.		13547	IN	CNAME	www.naver.com.nheos.com.
www.naver.com.nheos.com. 71	IN	A	210.89.160.88
www.naver.com.nheos.com. 71	IN	A	125.209.222.142

;; AUTHORITY SECTION:
nheos.com.		166525	IN	NS	gns2.nheos.com.
nheos.com.		166525	IN	NS	gns1.nheos.com.
nheos.com.		166525	IN	NS	gns3.nheos.com.

;; ADDITIONAL SECTION:
gns1.nheos.com.		14725	IN	A	103.6.174.86
gns2.nheos.com.		14113	IN	A	210.89.165.22
gns3.nheos.com.		14304	IN	A	125.209.246.230

;; Query time: 1 msec
;; SERVER: 192.168.122.1#53(192.168.122.1)
;; WHEN: Thu Feb 27 10:19:10 KST 2020
;; MSG SIZE  rcvd: 213
```

### netstat
- `netstat -nr` = route
- `netstat -ntulp`
	- `n`: 숫자
	-  `t`: TCP
	- `u`: UDP
	- `l`: Listen
	- `p`: Program
- `netstat -an`

## Interface Aggregation
https://ko.wikipedia.org/wiki/링크_애그리게이션

### Network Teaming
인터페이스 1개에 물리 랜카드 2개를 합침 (bonding, teaming)

1. 랜카드 추가
2. 인터페이스 만들기
3. 랜카드를 인터페이스에 연결

####  랜카드 추가
VM 에  랜카드 추가 
![create-network](https://user-images.githubusercontent.com/9030565/75405740-df316200-5951-11ea-8900-50961e39b784.png)

```bash
# VM
$ nmcli dev # ens9 ens10가 추가됨
DEVICE      TYPE      STATE      CONNECTION         
virbr0      bridge    connected  virbr0             
ens10       ethernet  connected  Wired connection 2 
ens9        ethernet  connected  Wired connection 1 
eth0        ethernet  connected  eth0               
lo          loopback  unmanaged  --                 
virbr0-nic  tun       unmanaged  --     

## 실제로 존재하지 않는 내용이기 때문에 제거 후 설정 파일부터 다시 생성
$ nmcli connection delete 'Wired connection 1'
Connection 'Wired connection 1' (be9f8817-b152-3150-88de-8f710b7965b1) successfully deleted.
$ nmcli connection delete 'Wired connection 2'
Connection 'Wired connection 2' (bae93ce6-08e5-349f-aac5-99f783f544c0) successfully deleted.

$ nmcli dev
DEVICE      TYPE      STATE         CONNECTION 
virbr0      bridge    connected     virbr0     
eth0        ethernet  connected     eth0       
ens10       ethernet  disconnected  --         
ens9        ethernet  disconnected  --         
lo          loopback  unmanaged     --         
virbr0-nic  tun       unmanaged     --         
```

#### teaming
기존 linux bonding울 보완하여 CentOS7 부터 지원하는 네트워크 이중화 구성

##### teaming - 인터페이스 만들기
```bash
$ nmcli connection add type team con-name team0 ifname team0 autoconnect yes config '{"runner": {"name": "activebackup"}}'
Connection 'team0' (4fe0aaff-1388-48d2-b66f-159eb8b99dc2) successfully added.

$ ls /etc/sysconfig/network-scripts/
... ifcfg-team0 ...

$ nmcli connection modify team0 ipv4.addresses 192.168.122.22/24 ipv4.method manual
```

##### teaming - 인터페이스에 랜카드 연결
```bash
$ nmcli connection add type team-slave con-name team0-port1 ifname ens9 master team0
Connection 'team0-port1' (a1976d18-1769-46b4-adb6-8ff18f385325) successfully added.

$ nmcli connection add type team-slave con-name team0-port2 ifname ens10 master team0
Connection 'team0-port2' (29db48ef-dfc3-4632-ab17-4a18111a1aaa) successfully added.

$ ls /etc/sysconfig/network-scripts/
... ifcfg-team0 ifcfg-team0-port1 ifcfg-team0-port2 ...

## 위까진 설정 파일만 만든것
$ systemctl restart network # 설정 파일 적용

$ ifconfig
...
team0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.122.22  netmask 255.255.255.0  broadcast 192.168.122.255
        ether 52:54:00:8d:c2:50  txqueuelen 1000  (Ethernet)
        RX packets 10  bytes 1381 (1.3 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 17  bytes 1999 (1.9 KiB)
        TX errors 0  dropped 2 overruns 0  carrier 0  collisions 0
...

$ eamdctl team0 state
setup:
  runner: activebackup
ports:
  ens10
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
  ens9
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
runner:
  active port: ens9
```
- ifname: 추가한 랜카드 이름, `ens`{}
- master: 인터페이스 이름

##### teaming - team 관리
``` bash
$ teamdctl team0 state item set runner.active_port ens10 # active port 변경

$ teamdctl team0 state
setup:
  runner: activebackup
ports:
  ens10
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
  ens9
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
runner:
  active port: ens10
```

##### teaming - 장애 발생 시나리오
```bash
$ nmcli device disconnect ens10 # 장애 상황으로 active가 down이라 가정
Device 'ens10' successfully disconnected.

$ teamdctl team0 state
setup:
  runner: activebackup
ports:
  ens9
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
runner:
  active port: ens9

$ nmcli connection up team0-port2 # 장애 해결로 up이라 가정
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/15)

$ teamdctl team0 state
setup:
  runner: activebackup
ports:
  ens10
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
  ens9
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
runner:
  active port: ens9
```

##### teaming - 설정 파일로 관리하기
```bash
$ vi /etc/sysconfig/network-scripts/ifcfg-team0 # runner 변경
TEAM_CONFIG="{\"runner\": {\"name\": \"loadbalance\"}}"
	# nmcli connection modify config '{"runner": {"name": "loadbalance"}}'

$ systemctl restart network

$ teamdctl team0 state
setup:
  runner: loadbalance
ports:
  ens10
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
  ens9
    link watches:
      link summary: up
      instance[link_watch_0]:
        name: ethtool
        link: up
        down count: 0
```
- runner
	- `activebackup` : 하나가 동작, 나머지 대기
	- `loadbalance`: 밸런싱

### Interface Bridging

#### 브릿지
1. bridge 생성
2. bridge-slave 생성
3. vlan 생성
4. 


#####  team 정보 모두 제거
```bash
# VM
$ nmcli device disconnect ens9
$ nmcli device disconnect ens10
$ nmcli connection delete team0
$ nmcli connection delete team0-port1
$ nmcli connection delete team0-port2

$ systemctl restart network

$ ifconfig
```
#####  브릿지 만들기
```bash
$ nmcli connection add type bridge con-name br0 ifname br0 autoconnect yes
Connection 'br0' (c3c0cf27-5c8e-4b0c-91c9-4ad7ede92334) successfully added.

$ nmcli connection modify br0 ipv4.addresses 192.168.122.33/24 ipv4.method manual
```

##### 브릿지에 랜카드 연결
``` bash
$ nmcli connection add type bridge-slave con-name br0-port1 ifname ens9 master br0
Connection 'br0-port1' (e40dbe49-5318-45aa-b0e3-dc6cf5ab6965) successfully added.

$ systemctl restart network
$ ifconfig
```
##### 브릿지 관리
```bash
$ brctl show
bridge name	bridge id		STP enabled	interfaces
br0		8000.5254008dc250	yes		ens9
virbr0		8000.5254004f18fc	yes		virbr0-nic
```

#####  VLAN
```bash
$ nmcli dev # VLAN으로 사용할 랜카드가 연결되지 않았는지 확인
DEVICE      TYPE      STATE         CONNECTION 
br0         bridge    connected     br0        
virbr0      bridge    connected     virbr0     
ens9        ethernet  connected     br0-port1  
eth0        ethernet  connected     eth0       
ens10       ethernet  disconnected  --         
lo          loopback  unmanaged     --         
virbr0-nic  tun       unmanaged     --       

$ nmcli connection add type vlan con-name vlan10 dev ens10 id 10 # vlan 추가
Connection 'vlan10' (7af6c451-07b7-4c17-8c49-2467f23cc721) successfully added.

$ nmcli connection modify vlan10 ipv4.addresses 192.168.122.44/24 ipv4.gateway 192.168.122.1 ipv4.dns 192.168.122.1 ipv4.method manual # vlan 정보 수정

$ nmcli connection up vlan10 # network 재시작하지 않고 vlan 정보 설정하기
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/29)

$ ifconfig
...
ens10.10: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.122.44  netmask 255.255.255.0  broadcast 192.168.122.255
        ether 52:54:00:9e:81:53  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 27  bytes 4323 (4.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
...

$ lsmod | grep 802 # 브릿지 설정 모듈 존재하는지 확인
8021q                  33104  0
```


### Tuning Kernel Network
```bash
# host
# VM에 ping 테스트
$ ping -c 3 192.168.122.149
PING 192.168.122.149 (192.168.122.149) 56(84) bytes of data.
64 bytes from 192.168.122.149: icmp_seq=1 ttl=64 time=0.178 ms
64 bytes from 192.168.122.149: icmp_seq=2 ttl=64 time=0.182 ms
64 bytes from 192.168.122.149: icmp_seq=3 ttl=64 time=0.341 ms

--- 192.168.122.149 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2000ms
rtt min/avg/max/mdev = 0.178/0.233/0.341/0.077 ms
[root@station14 /]# ping -c 3 192.168.122.149
PING 192.168.122.149 (192.168.122.149) 56(84) bytes of data.
```
- ping 제대로 동작

```bash
# VM
$ vi /etc/sysctl.conf # ICMP 무시 설정 추가
net.ipv4.icmp_echo_ignore_all = 1

$ sysctl -p # reboot 없이 설정 적용
```
- ping  설정으로 무시

```bash
# host
ping -c 3 192.168.122.149
PING 192.168.122.149 (192.168.122.149) 56(84) bytes of data.

--- 192.168.122.149 ping statistics ---
3 packets transmitted, 0 received, 100% packet loss, time 1999ms
```
- ping 동작하지 않음

# 컨테이너를 위한 보안 설정 SELinux



커널
- File system
- H/W driver
- SELinux
	- [LSM](https://ko.wikipedia.org/wiki/리눅스_보안_모듈)
	- Network

접근 제어 모델
- DAC: 임의 접근 제어
	- unix 의 퍼미션
	- 소유자가 잘못된 세팅을 할 수 있는 단점이 있음
- MAC: 강제 접근 제어
	- `policy`가 핵심
	- 정책을 위반한 접근은 차단 (퍼미션이 있다고 하더라도)
	- SELinux
	- 중앙 집중화된 관리가 가능
- RAC: 역할 기반 접근 제어


```bash
# host
# Security Context 확인

$ id
uid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

$ ll -Z # Security Context 확인

$ ps -eZ # Security Context 확인
```

## SELinux

SELinx가 보안 정책을 가져옴 
1.퍼미션 확인 2.라벨 확인 모두 OK -> 접근 허가가

### SELinux 동작 확인
1. 웹 서버로 SELinux 동작 확인
2. 모드 변경

``` bash
# VM
$ getenforce # Enforcing 가 나와야 한다.
Enforcing
```

#### 웹 서버로 SELinux 동작 확인

**퍼미션이 같은 파일이라도 `SELinux`의 라벨 설정에 따라 접근이 가능 여부가 달라진다.**

```bash
$ yum -y install httpd

$ cd /root
$ cp initial-setup-ks.cfg /var/www/html/1.html
$ mv initial-setup-ks.cfg /var/www/html/2.html

$ ll /var/www/html/
total 8
-rw-r--r--. 1 root root 1546 Feb 27 12:37 1.html
-rw-r--r--. 1 root root 1546 Feb 25 09:09 2.html


$ systemctl start httpd # 웹 서버 실행

## 브라우저에서 http://127.0.0.1/
## 1.html 2.html 접근 가능 여부가 다름

$ ll -Z /var/www/html/
-rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 1.html
-rw-r--r--. root root system_u:object_r:admin_home_t:s0 2.html
```
- http://127.0.0.1/1.html : 접근 가능
- http://127.0.0.1/2.html : 접근 불가 (403)

### SELinux 모드 enforcing permissive disable
##### enforcing
강제 모드
접근을 위반할 시 `차단, 로깅`

##### permissive
접근을 위반할 시 `로깅`

##### disable
접근을 위반할 시 `아무것도 하지 않음`


#### 모드 변경
##### SELinux change
- `set enforce 1`: permissive -> enforcing
- `set enforce 0`: enforcing -> permissive
> 부팅 상태에서만 가능

##### SELinux on/off
 disable <-> permissive/enforcing
 > 명령어로 불가
 > 부팅 시 결정됨
 >  `/etc/sysconfig/selinux`의 설정으로 결정됨


```bash
# VM
$ getenforce
Enforcing

$ setenforce 0
$ getenforce
Permissive
# http://127.0.0.1/2.html 접근 가능

$ setenforce 1
$ getenforce
Enforcing
# http://127.0.0.1/2.html 접근 불가(403)
```

```bash
# VM
$ vi /etc/sysconfig/selinux
SELINUX=disabled

$ reboot

$ getenforce
Disabled

# VM 종료
# `snapshot1`로 롤백
```

### SELinux 명령어
`snapshot1`로 돌아간 뒤 실습

```bash
$ matchpathcon /tmp /etc /root /boot
```
- matchpathcon: security context 확인
- chcon
	- `-t` type
<!--stackedit_data:
eyJoaXN0b3J5IjpbODg3MzgzNzI5LC0xODI4MzUwMywxMDYwND
YwMDQxLC0xMTA1MzIzMTksMTYzMzIwMTEzOCwtOTg4MDAyNjg0
LC0xMjgzMTIxMjksLTE5MzY5MjgyODMsLTc3MzA3ODYzMywyMD
UyNTI3NzM1LDUyODk5NzczNSwtMTUwNjYwNDkwMCwtMTIzMTU2
MzgzOCw4Njg4MDA5MzcsMjM5NjMxMzQzLC0xNjIwMDY3NDQsLT
g0OTI3NTUyMCwxMzYwNjU4MDE3LC0yMDg4NzQ2NjEyXX0=
-->