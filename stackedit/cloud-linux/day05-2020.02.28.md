# 컨테이너를 위반 기반 기술

https://hub.docker.com

### Dockerfile
https://github.com/docker-library/httpd/blob/4faace97468d7bced1ac4a072f89f151359ee9fa/2.4/Dockerfile

## chroot
> 특정 디렉토리를 최상위 `/`처럼 보이게 변경

```bash
# host
$ mkdir -p ~/newroot/bin
$ mkdir -p ~/newroot/lib64

$ chroot ~/newroot /bin/bash # 참조 라이브러리가 없어서 오류 발생
chroot: failed to run command ‘/bin/bash’: No such file or directory

$ ldd /bin/bash # 명령어가 참조하는 라이브러리 확인
	linux-vdso.so.1 =>  (0x00007ffc1ffdc000)
	libtinfo.so.5 => /lib64/libtinfo.so.5 (0x00007fa702bd9000)
	libdl.so.2 => /lib64/libdl.so.2 (0x00007fa7029d5000)
	libc.so.6 => /lib64/libc.so.6 (0x00007fa702613000)
	/lib64/ld-linux-x86-64.so.2 (0x00007fa702e17000)

# bash 명령에 필요한 라이브러리들 복사
$ cp /lib64/libtinfo.so.5 ~/newroot/lib64
$ cp /lib64/libdl.so.2  ~/newroot/lib64
$ cp /lib64/libc.so.6 ~/newroot/lib64
$ cp /lib64/ld-linux-x86-64.so.2  ~/newroot/lib64
$ cp /bin/bash ~/newroot/bin

$ chroot ~/newroot /bin/bash
bash-4.2# pwd
/
bash-4.2# ls
bash: ls: command not found # ls에 관련된 라이브러리는 복사하지 않았기 때문에 명령어 오류
```

```bash
# host
$ mkdir /tmp/ram
$ cd /tmp/ram

$ /lib/dracut/skipcpio /boot/initramfs-3.10.0-514.26.1.el7.x86_64.img  | zcat | cpio -icdmu # initramfs-3.10.0-514.26.1.el7.x86_64.img = 램디스크
145044 blocks

$ ls /tmp/ram
bin  dev  etc  init  lib  lib64  proc  root  run  sbin  shutdown  sys  sysroot  tmp  usr  var
```
- 복구 모드에서 하드 디스크 대신 램 디스트로 부팅됨
- `sysroot`: 실제 하드 디스크가 마운트되는 위치
	- `chroot sysroot` : 램 디스크 부팅 환경에서 오류 해결을 위해 실제 하드 디스크를 `root`로 보이게 한다

#### 장애 상황 구현으로 chroot
1.  VM 재부팅
2. e 누름
![부팅시 e](https://user-images.githubusercontent.com/9030565/75500970-e5871300-5a11-11ea-9695-c63003868968.png)
3. `rd.break` 추가 
UTF-8 뒤에 한 칸 띄고 추가
![rd break 추가](https://user-images.githubusercontent.com/9030565/75500972-e750d680-5a11-11ea-8e85-236204913d80.png)
5. ctrl + x
![램디스크로 부팅](https://user-images.githubusercontent.com/9030565/75500981-ed46b780-5a11-11ea-919f-27c4453b9d59.png)
6. `switch_root>` 진입
```bash
# 장애 상황
# VM

VM 재부팅
e 누름
`linux16 ~ UTF-8` rd.break 
ctrl + x 누름

switch_root> pwd
/
switch_root> ls

switch_root> mount -o remount,rw /sysroot # /sysroot 변경 가능하게 

switch_root> chroot /sysroot # 실제 하드디스크로 root 변경
sh-4.2> ls
sh-4.2> passwd # hak
sh-4.2> touch /.autorelabel # 반드시 해줘야함. 뭔가 바뀌었다는 것을 알려주는 용도
sh-4.2> exit # chroot 빠져나옴
switch_root> exit # 램 디스트 빠져나옴

# 다시 부팅되고 root 비밀번호 바뀐 것을 확인할 수 있다
```
- `rd.break`: 램 디스크에서 정지 시키고 부팅
	- 검은 화면으로 나온다 (스샷)


## 네임스페이스
> 프로세스 격리

- `clone()`
- `unshare()`
- `setna()`

```bash
$ unshare -f -p --mount-proc /bin/sh
sh-4.2> ps -ef # 프로세스를 격리했기 때문에 아래 두개만 나옴
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 10:32 pts/0    00:00:00 /bin/sh
root         3     1  0 10:33 pts/0    00:00:00 ps -ef
sh-4.2> exit

unshare -f /bin/sh
sh-4.2> ps -ef # 위에서의 결과와 다름, 전체가 나옴
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 10:01 ?        00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 
root         2     0  0 10:01 ?        00:00:00 [kthreadd]
root         3     2  0 10:01 ?        00:00:00 [ksoftirqd/0]
root         6     2  0 10:01 ?        00:00:00 [kworker/u2:0]
root         7     2  0 10:01 ?        00:00:00 [migration/0]
root         8     2  0 10:01 ?        00:00:00 [rcu_bh]
root         9     2  0 10:01 ?        00:00:00 [rcu_sched]
root        10     2  0 10:01 ?        00:00:00 [watchdog/0]

...

```

### PID Namespace
```bash
$ pstree
```
- kernel: pid 0
- systemd: pid 1 (CentOS 7 이전엔 `init`)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyMTQ3MzMzODUsMjQzNDI4NTIxLDE4MD
QzNTE5MjIsMzA5NDQwNzgzLDg5OTAwMjc5NCwyNDQxODI3MzMs
MTYwNjE0MjExOCwxNTgyNTE0NzM5LC0yMDg4NzQ2NjEyXX0=
-->